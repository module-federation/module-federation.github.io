{"pageProps":{"content":"# A Little Background\n\nIf you've worked as a developer long enough, you've ran into the inevitable problem of sharing components between teams. Let's be real here, how often does this lead to a good experience for anyone?\n\nI think [Zack Jackson](https://indepth.dev/webpack-5-module-federation-a-game-changer-in-javascript-architecture/), one of the authors of Webpack Module Federation said it best:\n\n> A scalable solution to sharing code between independent applications has never been convenient, and near impossible at scale. The closest we had was externals or DLLPlugin, forcing centralized dependency on a external file. It was a hassle to share code, the separate applications were not truly standalone and usually, a limited number of dependencies are shared. Moreover, sharing actual feature code or components between separately bundled applications is unfeasible, unproductive, and unprofitable.\n\nIf you would like to learn more about Webpack Module Federation, you can head over to the and check out [https://indepth.dev/webpack-5-module-federation-a-game-changer-in-javascript-architecture/](https://indepth.dev/webpack-5-module-federation-a-game-changer-in-javascript-architecture/ \"https://indepth.dev/webpack-5-module-federation-a-game-changer-in-javascript-architecture/\").\n\n# What We Are Building\n\nWe are going to build out two separate Single Page Applications (SPA) that use Module Federation to share components during runtime.\n\n`Application A` will contain a `SayHelloFromA` component that will be consumed by `Application B` while `Application B` will contain a `SayHelloFromB` component that will be consumed by `ApplicationA`. This looks like:\n\n![](/get-started-diagram.svg \"Architecture Diagram\")\n\nThis architecture will allow each SPA to be developed and deployed independantly along with instantly recieving updates from other federated applications with zero deployments.\n\n# TL;DR\n\nYou can find the completed source for this example at [https://github.com/jacob-ebey/federated-libraries-get-started](https://github.com/jacob-ebey/federated-libraries-get-started).\n\n# Getting Setup\n\nLet's start by getting our environment configured. We will be using a yarn mono-repo structure here for simplicity, but the idea behind Module Federation is to allow teams to operate autonomously, so in the real world, your SPA's would most likely live in their own repositories.\n\nStart by creating a new project folder with the following `package.json` to allow us to run our two SPAs at the same time:\n\n**package.json**\n\n```json\n{\n  \"name\": \"federation-example\",\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ],\n  \"scripts\": {\n    \"start\": \"wsrun --parallel start\",\n    \"build\": \"yarn workspaces run build\",\n    \"dev\": \"wsrun --parallel dev\"\n  },\n  \"devDependencies\": {\n    \"wsrun\": \"^5.2.0\"\n  }\n}\n```\n\nWe will now create two folders for our SPAs to live in under a new `packages` directory called `application-a` and `application-b`, these will respectively contain the following `package.json` files:\n\n**packages/application-a/package.json**\n\n```json\n{\n  \"name\": \"application-a\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"serve dist -p 3001\",\n    \"build\": \"webpack --mode production\",\n    \"dev\": \"concurrently \\\"webpack --watch\\\" \\\"serve dist -p 3001\\\"\"\n  },\n  \"dependencies\": {\n    \"react\": \"^16.13.1\",\n    \"react-dom\": \"^16.13.1\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.8.6\",\n    \"@babel/preset-react\": \"^7.8.3\",\n    \"babel-loader\": \"^8.0.6\",\n    \"concurrently\": \"^5.1.0\",\n    \"html-webpack-plugin\": \"git://github.com/ScriptedAlchemy/html-webpack-plugin#master\",\n    \"serve\": \"^11.3.0\",\n    \"webpack\": \"git://github.com/webpack/webpack.git#dev-1\",\n    \"webpack-cli\": \"^3.3.11\"\n  }\n}\n```\n**packages/application-b/package.json**\n\n```json\n{\n  \"name\": \"application-b\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"serve dist -p 3002\",\n    \"build\": \"webpack --mode production\",\n    \"dev\": \"concurrently \\\"webpack --watch\\\" \\\"serve dist -p 3002\\\"\"\n  },\n  \"dependencies\": {\n    \"react\": \"^16.13.1\",\n    \"react-dom\": \"^16.13.1\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.8.6\",\n    \"@babel/preset-react\": \"^7.8.3\",\n    \"babel-loader\": \"^8.0.6\",\n    \"concurrently\": \"^5.1.0\",\n    \"html-webpack-plugin\": \"git://github.com/ScriptedAlchemy/html-webpack-plugin#master\",\n    \"serve\": \"^11.3.0\",\n    \"webpack\": \"git://github.com/webpack/webpack.git#dev-1\",\n    \"webpack-cli\": \"^3.3.11\"\n  }\n}\n```\n\nInstall the dependancies with:\n\n```bash\n> yarn\n```\n\n## Bootstrap The SPAs\n\nNext up is bootstraping our SPA React applications. We need to create a `src` directory in each of our packages that contain the following files:\n\n**packages/application-{a,b}/src/index.js**\n\n```javascript\nimport('./bootstrap');\n```\n**packages/application-{a,b}/src/bootstrap.jsx**\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './app';\n\nReactDOM.render(<App />, document.getElementById('root'));\n```\nWe also need a `public` directory in each of the packages with the the following html template that we will modify per SPA later:\n\n**packages/application-{a,b}/public/index.html**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n```\n\nNow we can implement our two `app.jsx` files for each application that will house our shared components:\n\n**packages/application-a/src/app.jsx**\n\n```javascript\nimport React from 'react';\n\nexport default function SayHelloFromA() {\n  return <h1>Hello from Application A!</h1>;\n}\n```\n\n**packages/application-b/src/app.jsx**\n\n```javascript\nimport React from 'react';\n\nexport default function SayHelloFromB() {\n  return <h1>Hello from Application B!</h1>;\n}\n```\n\nAnd now finally, we'll add our base `webpack.config.js` for each application:\n\n**packages/application-{a,b}/webpack.config.js**\n\n```javascript\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nconst mode = process.env.NODE_ENV || 'production';\n\nmodule.exports = {\n  mode,\n  entry: './src/index',\n  devtool: 'source-map',\n  optimization: {\n    minimize: mode === 'production',\n  },\n  resolve: {\n    extensions: ['.jsx', '.js', '.json'],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?$/,\n        loader: require.resolve('babel-loader'),\n        options: {\n          presets: [require.resolve('@babel/preset-react')],\n        },\n      },\n    ],\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html',\n    }),\n  ],\n};\n```\n\nFrom the root of the application, you should now be able to access your two SPAs on [http://localhost:3001](http://localhost:3001) and [http://localhost:3002](http://localhost:3002) when runing:\n\n```bash\n> yarn dev\n```\n\n# Start Federating\n\nNow that we have two independnt SPAs running, let's go ahead and make each of the SPAs a Fedeated Container as well as Consumer. We accomplish this by utilizing the new `ModuleFederationPlugin` that is part of the Webpack 5 Core.\n\nWe'll start by adding the `ModuleFederationPlugin` to `Application A`, this will look like:\n\n**packages/application-a/webpack.config.js**\n\n```javascript\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nconst mode = process.env.NODE_ENV || 'production';\n\nmodule.exports = {\n  mode,\n  entry: './src/index',\n  output: {\n    publicPath: 'http://localhost:3001/', // New\n  },\n  devtool: 'source-map',\n  optimization: {\n    minimize: mode === 'production',\n  },\n  resolve: {\n    extensions: ['.jsx', '.js', '.json'],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?$/,\n        loader: require.resolve('babel-loader'),\n        options: {\n          presets: [require.resolve('@babel/preset-react')],\n        },\n      },\n    ],\n  },\n\n  plugins: [\n    // New\n    new ModuleFederationPlugin({\n      name: 'application_a',\n      library: { type: 'var', name: 'application_a' },\n      filename: 'remoteEntry.js',\n      exposes: {\n        'SayHelloFromA': './src/app',\n      },\n      remotes: {\n        'application_b': 'application_b',\n      },\n      shared: ['react', 'react-dom'],\n    }),\n    new HtmlWebpackPlugin({\n      template: './public/index.html',\n    }),\n  ],\n};\n```\n\nThis specifies that `Application A` exposese it's App component to the world as a Federated Module called `SayHelloFromA`, while whenever you import from `application_b`, those modules should come from `Application B` at runtime.\n\nWe will do the same thing fro `Applicaiton B`, specifying that it exposes it's App component as `SayHelloFromB` and whenever we import from `application_a`, those modules should come from `Application A` at runtime:\n\n**packages/application-b/webpack.config.js**\n\n```javascript\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nconst mode = process.env.NODE_ENV || 'production';\n\nmodule.exports = {\n  mode,\n  entry: './src/index',\n  output: {\n    publicPath: 'http://localhost:3002/', // New\n  },\n  devtool: 'source-map',\n  optimization: {\n    minimize: mode === 'production',\n  },\n  resolve: {\n    extensions: ['.jsx', '.js', '.json'],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?$/,\n        loader: require.resolve('babel-loader'),\n        options: {\n          presets: [require.resolve('@babel/preset-react')],\n        },\n      },\n    ],\n  },\n\n  plugins: [\n    // New\n    new ModuleFederationPlugin({\n      name: 'application_b',\n      library: { type: 'var', name: 'application_b' },\n      filename: 'remoteEntry.js',\n      exposes: {\n        'SayHelloFromB': './src/app',\n      },\n      remotes: {\n        'application_a': 'application_a',\n      },\n      shared: ['react', 'react-dom'],\n    }),\n    new HtmlWebpackPlugin({\n      template: './public/index.html',\n    }),\n  ],\n};\n```\n\nThe last step before we can start to utilize the exposed components is to specify for the runtime where the Remote Entries for the Containers you wish to consume are located. We do this by simply adding a script tag to the HTML template of the remotes you wish to consume.\n\n**packages/application-a/public/index.html**\n\n```html\n<head>\n  <!-- The remote entry for Application B -->\n  <script src=\"http://localhost:3002/remoteEntry.js\"></script>    \n</head>\n```\n\n**packages/application-b/public/index.html**\n\n```html\n<head>\n  <!-- The remote entry for Application A -->\n  <script src=\"http://localhost:3001/remoteEntry.js\"></script>    \n</head>\n```\n\nThe remote entry files are tiny mappings for webpack to resolve the individually imported modules without trasfering unnessesary info. They are also responsible for enabling the sharing of libraries that the packages use, in this case, when `Application A` requests `Application B`'s SayHelloFromB component, we do not send the React or ReactDOM over the wire as `Application A` already has a copy of it.\n\n## Consuming Federated Components\n\nNow that our two SPA applications are Container Hosts and Consumers, we can start to consume the shared components. In the webpack config we had specified the names of the containers as `application_a` and `application_b`, so that is where we will import the components from.\n\nStarting with `Application A`, we can render the `SayHelloFromB` component like so from within the bootstrap file:\n\n**packages/application-a/src/bootstrap.jsx**\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport SayHelloFromB from 'application_b/SayHelloFromB';\n\nimport App from './app';\n\nReactDOM.render(\n  <>\n  \t<App />\n  \t<SayHelloFromB />\n  </>,\n  document.getElementById('root')\n);\n```\n\n`Application B` will look very similar, just importing from `application_a` instead:\n\n**packages/application-b/src/bootstrap.jsx**\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport SayHelloFromA from 'application_a/SayHelloFromA';\n\nimport App from './app';\n\nReactDOM.render(\n  <>\n    <App />\n    <SayHelloFromA />\n  </>,\n  document.getElementById('root')\n);\n```\n\n# A Few Notes\n\nLooking at the network log for `Application A` you will see that we load two files from `Application B`, the `remoteEntry.js` file, then the `977.js` that contains the `SayHelloFromB` component.\n\n![Application B Network Log](/application-a-network-log.png)\n\nVisiting `Application B` for the first time, you'll notice we have already cached the remoteEntries for both `Application B` and `Application A`.\n\n![Application B Network Log](/application-b-network-log.png)\n\n**You have just created your first Webpack 5 Federated projects. Now go out and build something awesome!**","data":{"title":"Getting Started With Federated Modules","secondary_title":"get up and running in 15 minutes","author":"Jacob Ebey","date":"2020-03-30"}},"__N_SSG":true}